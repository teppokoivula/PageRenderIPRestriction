<?php

/**
 * Page Render IP Restriction
 *
 * This module adds basic IP restriction capabilities for page rendering.
 * For detailed information, installation instructions etc. see README.md.
 *
 * @copyright Copyright (c) 2012, 2013 Teppo Koivula 
 * @license http://www.gnu.org/licenses/gpl-2.0.txt GNU General Public License, version 2 
 *
 * ProcessWire 2.x 
 * Copyright (C) 2012 by Ryan Cramer 
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 * 
 * http://www.processwire.com
 *
 */
class PageRenderIPRestriction extends WireData implements Module, ConfigurableModule {

    /**
     * Return information about this module (required)
     *
     * @return array
     */
    public static function getModuleInfo() {
        return array(

            // The module's title
            'title' => 'Page Render IP Restriction',

            // version: major, minor, revision, i.e. 100 = 1.0.0
            'version' => 62,

            // summary is brief description of what this module is
            'summary' => 'Basic IP restriction for page rendering.',

            // Optional URL to more information about the module
            'href' => 'https://github.com/teppokoivula/PageRenderIPRestriction',

            // singular=true: indicates that only one instance of the module is allowed.
            // This is usually what you want for modules that attach hooks. 
            'singular' => true,

            // autoload=true: indicates the module should be started with ProcessWire.
            // This is necessary for any modules that attach runtime hooks, otherwise those
            // hooks won't get attached unless some other code calls the module on it's own.
            // Note that autoload modules are almost always also 'singular' (seen above).
            'autoload' => true

        );
    }
    
    /**
     * Module configuration
     *
     * @param array $data
     * @return InputfieldWrapper
     */
    static public function getModuleConfigInputfields(array $data) {

        // this is a container for fields, basically like a fieldset
        $fields = new InputfieldWrapper();

        // since this is a static function, we can't use $this->modules, so get them from the global wire() function
        $modules = wire('modules');

        // allowed IPs
        $field = $modules->get("InputfieldTextarea");
        $field->name = "allowed_ips";
        $field->label = "Allowed IPs";
        $field->description = "Each address on it's own line.";
        if (isset($data[$field->name])) $field->value = $data[$field->name];
        $field->notes = "Supported formats: 127.0.0.1 (individual IPs), 127.0.0.1-127.0.0.255 (IP ranges) and 127.0.0.0/24 (CIDR)";
        $field->rows = 10;
        $fields->add($field);

        // message to show when denying access
        $field = $modules->get("InputfieldTextarea");
        $field->name = "access_denied_message";
        $field->label = "Access denied message";
        $field->description = "What message should users get when they're being denied access?";
        $field->notes = "Leave blank to show no message. HTML markup is supported.";
        if (isset($data[$field->name])) $field->value = $data[$field->name];
        $fields->add($field);

        // action to take when access is denied
        $field = $modules->get("InputfieldSelect");
        $field->name = "access_denied_action";
        $field->label = "Access denied action";
        $field->description = "What should happen when user is denied access?";
        $field->notes = "Option \"Redirect user to login page\" has no effect if admin access is also restricted.";
        $field->addOptions(array(
            'exit_with_message' => 'Exit with specified message',
            'redirect_to_admin' => 'Redirect user to login page'
        ));
        if (isset($data[$field->name])) $field->value = $data[$field->name];
        $fields->add($field);

        // should admin pages be accessible even from outside valid IPs?
        $field = $modules->get("InputfieldCheckbox");
        $field->name = "restrict_admin_access";
        $field->label = "Restrict admin access";
        $field->description = "If you check this box, admin pages will only be available for users with valid IPs.";
        $field->checked = isset($data[$field->name]) && $data[$field->name];
        $fields->add($field);

        // should IP restriction apply to logged in users?
        $field = $modules->get("InputfieldCheckbox");
        $field->name = "restrict_authenticated_users_access";
        $field->label = "Restrict access for authenticated users";
        $field->description = "If you check this box, IP restriction will also apply to authenticated (logged in) users.";
        if (isset($data['restrict_authenticated_users_access']) && $data['restrict_authenticated_users_access']) $field->checked = true;
        $fields->add($field);

        return $fields;

    }

    /**
     * Initialize the module
     *
     * ProcessWire calls this when the module is loaded. For 'autoload' modules, this will be called
     * when ProcessWire's API is ready. As a result, this is a good place to attach hooks. 
     *
     */
    public function init() {

        // add a hook before each page render to check if IP restrictions apply
        if ($this->allowed_ips) $this->addHookBefore('Page::render', $this, 'beforeRender'); 

    }

    /**
     * beforeRender hooks into every page before it's rendered and checks if users IP is valid
     *
     * @param HookEvent $event
     */
    public function beforeRender(HookEvent $event) {

        // should admin pages be accessible even from outside valid IPs?
        if (!$this->restrict_admin_access && $event->object->template == 'admin') return;

        // should IP restriction apply to logged in users?
        if (!$this->restrict_authenticated_users_access && $this->user->isLoggedIn()) return;

        // return if current IP is valid (allowed)
        if ($this->isValidIP($_SERVER['REMOTE_ADDR'], $this->allowed_ips)) return;

        // access denied, take appropriate action
        if ($this->access_denied_action == "redirect_to_admin" && !$this->restrict_admin_access) {
            $this->session->redirect($this->wire->config->urls->admin);
        } else if ($this->access_denied_action == "exit_with_message") {
            exit($this->access_denied_message);
        } else {
            header("HTTP/1.1 403 Forbidden");
            exit;
        }

    }

    /**
     * Validate IP, optionally comparing it against a list of valid IPs
     *
     * @param string $ip IP address (IPv4)
     * @param array|string|null $valid_ips List of valid IP addresses
     * @return bool
     * @throws WireException if valid_ips is of invalid type or format
     */
    protected function isValidIP($ip, $valid_ips = null) {
        // validate IP address with PHP's native filter_var function
        if (!filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4)) {
            return false;
        }
        if (empty($valid_ips)) {
            // IP is valid and list of valid IPs empty (or not provided at all)
            return true;
        } else {
            // to continue, we need an array of valid IPs; if a string was given,
            // explode it from characters not expected in addresses to get an array
            if (is_string($valid_ips)) {
                $valid_ips = preg_split("/[^0-9\.\-\/]/", $valid_ips, -1, PREG_SPLIT_NO_EMPTY);
            } else if (!is_array($valid_ips)) {
                throw new WireException("Second param should be a list of valid IPs (array|string), " . gettype($valid_ips) . " given");
            }
            // iterate valid IPs / ranges / CIDRs until a match is found; return
            // true on first match, false at the end if no matches were found
            $long = ip2long($ip);
            foreach ($valid_ips as $valid_ip) {
                if (strpos($valid_ip, "-")) {
                    // IP range
                    list($f, $l) = explode("-", $valid_ip);
                    $f = ip2long($f);
                    $l = ip2long($l);
                    if ($f > $l) list($f, $l) = array($l, $f);
                    for ($i = $f; $i<$l+1; ++$i) {
                        if ($long == $i) return true;
                    }
                } else {
                    // single IP or CIDR format
                    $cidr = 32;
                    if (strpos($valid_ip, "/")) {
                        list($valid_ip, $cidr) = explode("/", $valid_ip);
                        if (!isset($cidr) || $cidr < 1 || $cidr > 32) $cidr = 32;
                    }
                    // accept only valid IPv4 addresses
                    if (filter_var($valid_ip, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4)) {
                        if ($cidr == 32 && $long == ip2long($valid_ip)) return true;
                        $mask = -1 << (32 - (int) $cidr);
                        if (($long & $mask) == ip2long($valid_ip)) return true;
                    }
                }
            }
            return false;
        }
    }

}